<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>An치lisis de Frenos - Sistema Judicial</title>
    <link rel="manifest" href="manifest.json">
    <style>
        html {
            font-size: 16px;
        }
        body {
            font-family: 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ebedef;
            color: #333;
            overscroll-behavior: none;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 1rem;
        }
        header {
            background-color: #2c3e50;
            color: #fff;
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header img {
            height: 2.5rem;
        }
        header .metadata {
            font-size: 0.9rem;
        }
        .tabs {
            display: flex;
            background-color: #34495e;
            border-radius: 0.5rem 0.5rem 0 0;
            flex-wrap: wrap;
        }
        .tab {
            flex: 1;
            padding: 0.8rem;
            text-align: center;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 1rem;
        }
        .tab.active {
            background-color: #3498db;
        }
        .tab-content {
            display: none;
            background-color: #fff;
            padding: 1rem;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1);
        }
        .tab-content.active {
            display: block;
        }
        button {
            padding: 0.8rem 1.5rem;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.3rem;
            transition: background-color 0.3s;
            min-height: 44px;
            touch-action: manipulation;
        }
        button:hover:not(:disabled) {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .input-group {
            margin: 0.8rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .input-group label {
            width: 9rem;
            font-weight: bold;
            font-size: 0.9rem;
        }
        .input-group input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
            width: 100%;
            max-width: 20rem;
            font-size: 0.9rem;
        }
        .checkbox-group {
            margin: 0.8rem 0;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .checkbox-group label {
            font-size: 0.9rem;
        }
        .status {
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .validation-seal {
            margin: 1rem 0;
            padding: 0.6rem;
            background-color: #e8f8e8;
            border-left: 0.25rem solid #2ecc71;
            font-size: 0.8rem;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 1rem;
            border-radius: 0.5rem;
            max-width: 90%;
            text-align: center;
            font-size: 0.9rem;
        }
        .graph-container {
            margin: 1rem 0;
            padding: 0.6rem;
            background-color: #f9f9f9;
            border-radius: 0.5rem;
            width: 100%;
            height: 40vh;
        }
        #mu-graph {
            width: 100% !important;
            height: 100% !important;
        }
        #reaccion {
            background-color: #1c2526;
            color: #fff;
            border-radius: 0.5rem;
            padding: 1.5rem;
        }
        .lights-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin: 1.5rem 0;
        }
        .lights-row {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .light {
            width: 15vmin;
            height: 15vmin;
            border-radius: 50%;
            background-color: #4a4a4a;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .light.encendida {
            background-color: #ff0000;
            box-shadow: 0 0 2rem rgba(255, 0, 0, 0.8), 0 0 0.6rem rgba(255, 255, 255, 0.5);
        }
        .reaction-area {
            width: 100%;
            height: 30vh;
            background-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #fff;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            touch-action: manipulation;
        }
        .reaction-result, .reaction-explanation {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            line-height: 1.6;
            animation: fadeIn 0.5s ease-in;
        }
        .reaction-result.false-start {
            color: #e74c3c;
            font-weight: bold;
        }
        #iniciar-test {
            padding: 0.9rem 2rem;
            font-size: 1.1rem;
            background-color: #e74c3c;
        }
        #iniciar-test:hover:not(:disabled) {
            background-color: #c0392b;
        }
        .bubble-level-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem auto;
            position: relative;
            width: 80vw;
            height: 80vw;
            max-width: 300px;
            max-height: 300px;
            background: radial-gradient(circle, #f0f0f0 0%, #d3d3d3 100%);
            border: 3px solid #333;
            border-radius: 50%;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #bubble-level {
            width: 100%;
            height: 100%;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @media (max-width: 768px) {
            html { font-size: 14px; }
            .tabs { flex-direction: column; }
            .tab { padding: 0.6rem; font-size: 0.9rem; }
            .input-group { flex-direction: column; align-items: flex-start; }
            .input-group label { width: 100%; }
            .input-group input { max-width: 100%; }
            .checkbox-group { flex-direction: column; gap: 0.5rem; }
            .graph-container { height: 35vh; }
            .light { width: 12vmin; height: 12vmin; }
            .lights-row { gap: 0.5rem; }
            .reaction-area { height: 25vh; font-size: 1.2rem; }
            button { padding: 0.6rem 1rem; font-size: 0.9rem; }
            .bubble-level-container { width: 70vw; height: 70vw; max-width: 250px; max-height: 250px; }
        }
        @media (max-width: 480px) {
            html { font-size: 12px; }
            .container { padding: 0.5rem; }
            header { padding: 0.5rem; }
            header img { height: 2rem; }
            .light { width: 10vmin; height: 10vmin; }
            .reaction-area { font-size: 1rem; }
            .modal-content { max-width: 95%; }
            .bubble-level-container { width: 60vw; height: 60vw; max-width: 200px; max-height: 200px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <img src="https://via.placeholder.com/150x40?text=Logo" alt="Logo">
        <div class="metadata">
            <span id="current-datetime"></span> | Versi칩n 1.0.0
        </div>
    </header>
    <div class="container">
        <h1>An치lisis de Frenos - Sistema Judicial</h1>
        <div class="tabs">
            <div class="tab active" onclick="openTab('nivel')">Nivel</div>
            <div class="tab" onclick="openTab('mu')">An치lisis 풮</div>
            <div class="tab" onclick="openTab('reaccion')">Tiempo de Reacci칩n</div>
        </div>

        <div id="nivel" class="tab-content active">
            <h2>Nivel de Inclinaci칩n</h2>
            <div class="bubble-level-container">
                <canvas id="bubble-level"></canvas>
            </div>
        </div>

        <div id="mu" class="tab-content">
            <h2>An치lisis del Coeficiente de Rozamiento (풮)</h2>
            <div class="input-group">
                <label>N칰mero de diligencias:</label>
                <input type="text" id="mu-diligencias" placeholder="Ej: 1234/2025">
                <label>Matr칤cula:</label>
                <input type="text" id="mu-matricula" placeholder="Ej: ABC1234">
            </div>
            <button id="start-recording">Iniciar Grabaci칩n</button>
            <button id="stop-recording" disabled>Detener Grabaci칩n</button>
            <p><strong>Estado:</strong> <span id="recording-status">No grabando</span></p>
            <p><strong>Estado GPS:</strong> <span id="gps-status">游늸 Esperando se침al</span></p>
            <p><strong>Coordenadas:</strong> <span id="gps-coords">N/A</span></p>
            <p><strong>Velocidad GPS:</strong> <span id="gps-speed">0.0 km/h</span></p>
            <p><strong>Precisi칩n GPS:</strong> <span id="gps-accuracy">N/A</span></p>
            <p><strong>Puntos GPS:</strong> <span id="gps-points">0</span></p>
            <div class="checkbox-group">
                <label><input type="checkbox" id="show-eje-x" checked onchange="updateGraph()"> Eje X</label>
                <label><input type="checkbox" id="show-eje-y" checked onchange="updateGraph()"> Eje Y</label>
                <label><input type="checkbox" id="show-eje-z" checked onchange="updateGraph()"> Eje Z</label>
                <label><input type="checkbox" id="show-velocidad" checked onchange="updateGraph()"> Velocidad</label>
            </div>
            <div class="graph-container">
                <canvas id="mu-graph"></canvas>
            </div>
            <p><strong>풮 Autom치tico:</strong> <span id="mu-auto">0.000</span></p>
            <p><strong>풮 Manual:</strong> <span id="mu-manual">0.000</span></p>
            <p class="status">Selecci칩n: <span id="selection-info">Haga clic en la gr치fica para seleccionar el tramo</span></p>
            <button onclick="downloadAccelerometerData()">Exportar Datos Aceler칩metro (CSV)</button>
            <button onclick="downloadGPSData()">Exportar Datos GPS (CSV)</button>
            <button onclick="generatePDFReport()">Generar Informe PDF</button>
            <div class="validation-seal">Datos certificados por An치lisis de Frenos | Hash: <span id="mu-hash">N/A</span></div>
            <p>
                <input type="checkbox" id="calcular-mu-auto" checked onchange="calculateAutoMU()"> C치lculo Autom치tico de 풮<br>
                <input type="checkbox" id="seleccionar-intervalo" onchange="toggleManualSelection()"> Selecci칩n Manual de Tramo
            </p>
        </div>

        <div id="reaccion" class="tab-content">
            <h2>Ensayo de Tiempo de Reacci칩n</h2>
            <div class="input-group">
                <label>N칰mero de diligencias:</label>
                <input type="text" id="reaccion-diligencias" placeholder="Ej: 1234/2025">
                <label>Matr칤cula:</label>
                <input type="text" id="reaccion-matricula" placeholder="Ej: ABC1234">
            </div>
            <div class="lights-wrapper">
                <div class="lights-row">
                    <div class="light" data-index="1"></div>
                    <div class="light" data-index="2"></div>
                    <div class="light" data-index="3"></div>
                    <div class="light" data-index="4"></div>
                    <div class="light" data-index="5"></div>
                </div>
                <div class="lights-row">
                    <div class="light" data-index="1"></div>
                    <div class="light" data-index="2"></div>
                    <div class="light" data-index="3"></div>
                    <div class="light" data-index="4"></div>
                    <div class="light" data-index="5"></div>
                </div>
            </div>
            <button id="iniciar-test">Iniciar Ensayo</button>
            <button id="export-pdf" disabled>Exportar Informe PDF</button>
            <div class="reaction-area" id="reaction-area">Prep치rate para interactuar cuando las luces se apaguen</div>
            <div class="reaction-result" id="reaction-result"></div>
            <div class="reaction-explanation" id="reaction-explanation"></div>
            <div class="validation-seal">Datos certificados por An치lisis de Frenos | Hash: <span id="reaction-hash">N/A</span></div>
        </div>

        <div class="modal" id="tutorial-modal">
            <div class="modal-content">
                <h2>Bienvenido al Sistema de An치lisis de Frenos</h2>
                <p>Esta aplicaci칩n realiza ensayos precisos para determinar el coeficiente de rozamiento (풮) y el tiempo de reacci칩n, dise침ada para uso en procedimientos judiciales.</p>
                <p><strong>Instrucciones:</strong></p>
                <ul>
                    <li>En "Nivel", utilice la burbuja como gu칤a para alinear el dispositivo (recomendado, pero no obligatorio).</li>
                    <li>En "An치lisis 풮", inicie la grabaci칩n para capturar datos de frenado.</li>
                    <li>En "Tiempo de Reacci칩n", realice el ensayo tocando la pantalla tras el apagado de las luces.</li>
                    <li>Exporte los datos en CSV o PDF para su uso en informes judiciales.</li>
                </ul>
                <button onclick="document.getElementById('tutorial-modal').style.display='none'">Entendido</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.0/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script>
        console.log('Iniciando script...');
        const { jsPDF } = window.jspdf || {};
        if (!window.Chart || !window.html2canvas || !window.saveAs || !jsPDF) {
            console.error('Error: Alguna dependencia (Chart.js, html2canvas, FileSaver, jsPDF) no se carg칩 correctamente');
        }

        let accelerometerData = { x: [], y: [], z: [], speed: [], time: [] };
        let gpsData = { lat: [], lon: [], speed: [], accuracy: [], time: [] };
        let isRecording = false;
        let manualSelection = { start: null, end: null };
        let calibration = { x: 0, y: 0, z: 9.81, angleX: 0, angleY: 0 };
        let watchId = null;
        let isLevelled = false;
        let angleBuffer = { x: [], y: [] }; // Buffer para suavizado

        // Actualizar fecha y hora
        function updateDateTime() {
            try {
                const now = new Date();
                document.getElementById('current-datetime').textContent = now.toLocaleString('es-ES', { timeZone: 'Europe/Madrid' });
            } catch (error) {
                console.error('Error en updateDateTime:', error);
            }
        }
        setInterval(updateDateTime, 1000);
        updateDateTime();

        // Mostrar tutorial al cargar
        try {
            document.getElementById('tutorial-modal').style.display = 'flex';
        } catch (error) {
            console.error('Error al mostrar modal:', error);
        }

        // Gesti칩n de pesta침as
        function openTab(tabId) {
            try {
                console.log('Abriendo pesta침a:', tabId);
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                const tabElement = document.querySelector(`[onclick="openTab('${tabId}')"]`);
                const contentElement = document.getElementById(tabId);
                if (!tabElement || !contentElement) {
                    console.error('Elemento no encontrado para tabId:', tabId);
                    return;
                }
                tabElement.classList.add('active');
                contentElement.classList.add('active');
                if (tabId === 'nivel') {
                    initBubbleLevel();
                }
            } catch (error) {
                console.error('Error en openTab:', error);
            }
        }

        // Configuraci칩n del nivel de burbuja
        const bubbleCanvas = document.getElementById('bubble-level');
        const bubbleCtx = bubbleCanvas ? bubbleCanvas.getContext('2d') : null;
        let bubbleRadius = 15;

        function initBubbleLevel() {
            try {
                console.log('Inicializando nivel de burbuja...');
                if (!bubbleCanvas || !bubbleCtx) {
                    console.error('Error: Canvas o contexto no disponible');
                    return;
                }
                resizeBubbleCanvas();
                window.addEventListener('resize', resizeBubbleCanvas);
                window.addEventListener('orientationchange', resizeBubbleCanvas);
            } catch (error) {
                console.error('Error en initBubbleLevel:', error);
            }
        }

        function resizeBubbleCanvas() {
            try {
                const container = document.querySelector('.bubble-level-container');
                if (!container || !bubbleCanvas) {
                    console.error('Error: Container o canvas no encontrado');
                    return;
                }
                bubbleCanvas.width = container.clientWidth;
                bubbleCanvas.height = container.clientHeight;
                bubbleRadius = Math.min(bubbleCanvas.width, bubbleCanvas.height) / 10;
                console.log('Canvas redimensionado:', bubbleCanvas.width, bubbleCanvas.height);
                drawBubble();
            } catch (error) {
                console.error('Error en resizeBubbleCanvas:', error);
            }
        }

        function drawBubble() {
            try {
                if (!bubbleCtx) {
                    console.error('Error: Contexto del canvas no disponible');
                    return;
                }
                bubbleCtx.clearRect(0, 0, bubbleCanvas.width, bubbleCanvas.height);

                // Fondo del nivel
                const centerX = bubbleCanvas.width / 2;
                const centerY = bubbleCanvas.height / 2;
                const outerRadius = Math.min(bubbleCanvas.width, bubbleCanvas.height) / 2 - 5;
                bubbleCtx.beginPath();
                bubbleCtx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                bubbleCtx.strokeStyle = '#333';
                bubbleCtx.lineWidth = 2;
                bubbleCtx.stroke();

                // L칤neas de referencia
                bubbleCtx.beginPath();
                bubbleCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                bubbleCtx.lineWidth = 1;
                bubbleCtx.moveTo(centerX, 0);
                bubbleCtx.lineTo(centerX, bubbleCanvas.height);
                bubbleCtx.moveTo(0, centerY);
                bubbleCtx.lineTo(bubbleCanvas.width, centerY);
                bubbleCtx.stroke();

                // Burbuja
                const maxTilt = 15;
                const smoothedAngleX = angleBuffer.x.length ? angleBuffer.x.reduce((sum, val) => sum + val, 0) / angleBuffer.x.length : 0;
                const smoothedAngleY = angleBuffer.y.length ? angleBuffer.y.reduce((sum, val) => sum + val, 0) / angleBuffer.y.length : 0;
                const maxOffset = outerRadius - bubbleRadius;
                const offsetX = (smoothedAngleX / maxTilt) * maxOffset;
                const offsetY = (smoothedAngleY / maxTilt) * maxOffset;

                bubbleCtx.beginPath();
                bubbleCtx.arc(centerX + offsetX, centerY + offsetY, bubbleRadius, 0, 2 * Math.PI);
                const gradient = bubbleCtx.createRadialGradient(
                    centerX + offsetX - bubbleRadius / 2,
                    centerY + offsetY - bubbleRadius / 2,
                    bubbleRadius / 4,
                    centerX + offsetX,
                    centerY + offsetY,
                    bubbleRadius
                );
                gradient.addColorStop(0, isLevelled ? '#2ecc71' : '#e74c3c');
                gradient.addColorStop(1, isLevelled ? '#27ae60' : '#c0392b');
                bubbleCtx.fillStyle = gradient;
                bubbleCtx.fill();
                bubbleCtx.strokeStyle = '#333';
                bubbleCtx.lineWidth = 1;
                bubbleCtx.stroke();
                console.log('Burbuja dibujada:', { angleX: smoothedAngleX, angleY: smoothedAngleY, isLevelled });
            } catch (error) {
                console.error('Error en drawBubble:', error);
            }
        }

        // Verificar compatibilidad de sensores
        if (!window.DeviceMotionEvent) {
            console.warn('DeviceMotionEvent no soportado');
        } else {
            window.addEventListener('devicemotion', event => {
                try {
                    const x = (event.accelerationIncludingGravity?.x || 0) - calibration.x;
                    const y = (event.accelerationIncludingGravity?.y || 0) - calibration.y;
                    const z = (event.accelerationIncludingGravity?.z || 0) - calibration.z;
                    calibration.angleX = Math.atan2(y, z) * (180 / Math.PI);
                    calibration.angleY = Math.atan2(x, z) * (180 / Math.PI);
                    // Suavizado: mantener los 칰ltimos 5 valores
                    angleBuffer.x.push(calibration.angleX);
                    angleBuffer.y.push(calibration.angleY);
                    if (angleBuffer.x.length > 5) angleBuffer.x.shift();
                    if (angleBuffer.y.length > 5) angleBuffer.y.shift();
                    isLevelled = Math.abs(calibration.angleX) < 1 && Math.abs(calibration.angleY) < 1;
                    drawBubble();
                    console.log('DeviceMotion:', { x, y, z, angleX: calibration.angleX, angleY: calibration.angleY, isLevelled });
                    if (isRecording) {
                        const time = performance.now() / 1000;
                        accelerometerData.x.push(x);
                        accelerometerData.y.push(y);
                        accelerometerData.z.push(z);
                        accelerometerData.speed.push(gpsData.speed[gpsData.speed.length - 1] || 0);
                        accelerometerData.time.push(time);
                        updateGraph();
                        calculateAutoMU();
                        console.log('Datos grabados:', { time, x, y, z });
                    }
                } catch (error) {
                    console.error('Error en DeviceMotionEvent:', error);
                }
            }, { passive: false });
        }

        // Captura de datos GPS
        function startGPS() {
            try {
                console.log('Iniciando GPS...');
                if (!navigator.geolocation) {
                    console.warn('Geolocation no soportado');
                    document.getElementById('gps-status').innerText = 'GPS no soportado';
                    return;
                }
                watchId = navigator.geolocation.watchPosition(
                    position => {
                        const time = performance.now() / 1000;
                        gpsData.lat.push(position.coords.latitude);
                        gpsData.lon.push(position.coords.longitude);
                        gpsData.speed.push(position.coords.speed ? position.coords.speed * 3.6 : 0);
                        gpsData.accuracy.push(position.coords.accuracy);
                        gpsData.time.push(time);
                        document.getElementById('gps-coords').innerText = `${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`;
                        document.getElementById('gps-speed').innerText = `${(position.coords.speed * 3.6).toFixed(1)} km/h`;
                        document.getElementById('gps-accuracy').innerText = `${position.coords.accuracy.toFixed(1)} m`;
                        document.getElementById('gps-points').innerText = gpsData.time.length;
                        document.getElementById('gps-status').innerText = '游늸 Se침al activa';
                        console.log('GPS actualizado:', { lat: position.coords.latitude, lon: position.coords.longitude, speed: position.coords.speed });
                    },
                    error => {
                        console.error('Error GPS:', error.message);
                        document.getElementById('gps-status').innerText = `Error GPS: ${error.message}`;
                    },
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
            } catch (error) {
                console.error('Error en startGPS:', error);
            }
        }

        // Gr치fica de An치lisis 풮
        let muChart = null;
        try {
            const ctx = document.getElementById('mu-graph').getContext('2d');
            muChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Eje X (m/s)', data: [], borderColor: '#e74c3c', hidden: false },
                        { label: 'Eje Y (m/s)', data: [], borderColor: '#3498db', hidden: false },
                        { label: 'Eje Z (m/s)', data: [], borderColor: '#2ecc71', hidden: false },
                        { label: 'Velocidad (km/h)', data: [], borderColor: '#f1c40f', hidden: false },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: false } },
                    plugins: {
                        title: { display: true, text: 'Datos de Frenado en Tiempo Real', font: { size: 1.2 * 16 } }
                    },
                    onClick: (event, elements, chart) => {
                        try {
                            if (document.getElementById('seleccionar-intervalo').checked) {
                                const xValue = chart.scales.x.getValueForPixel(event.offsetX);
                                if (!manualSelection.start) {
                                    manualSelection.start = Math.floor(xValue);
                                    document.getElementById('selection-info').innerText = `Inicio: ${manualSelection.start}. Seleccione el fin.`;
                                } else if (!manualSelection.end) {
                                    manualSelection.end = Math.floor(xValue);
                                    document.getElementById('selection-info').innerText = `Tramo: ${manualSelection.start} a ${manualSelection.end}`;
                                    calculateManualMU();
                                } else {
                                    manualSelection = { start: null, end: null };
                                    document.getElementById('selection-info').innerText = 'Haga clic en la gr치fica para seleccionar el tramo';
                                }
                                console.log('Selecci칩n en gr치fica:', manualSelection);
                            }
                        } catch (error) {
                            console.error('Error en onClick de gr치fica:', error);
                        }
                    }
                }
            });
            console.log('Gr치fica inicializada');
        } catch (error) {
            console.error('Error al inicializar gr치fica:', error);
        }

        function updateGraph() {
            try {
                if (!muChart) {
                    console.error('Error: Gr치fica no inicializada');
                    return;
                }
                muChart.data.labels = accelerometerData.time;
                muChart.data.datasets[0].data = accelerometerData.x;
                muChart.data.datasets[1].data = accelerometerData.y;
                muChart.data.datasets[2].data = accelerometerData.z;
                muChart.data.datasets[3].data = accelerometerData.speed;
                muChart.data.datasets[0].hidden = !document.getElementById('show-eje-x').checked;
                muChart.data.datasets[1].hidden = !document.getElementById('show-eje-y').checked;
                muChart.data.datasets[2].hidden = !document.getElementById('show-eje-z').checked;
                muChart.data.datasets[3].hidden = !document.getElementById('show-velocidad').checked;
                muChart.update();
                console.log('Gr치fica actualizada con', accelerometerData.time.length, 'puntos');
            } catch (error) {
                console.error('Error en updateGraph:', error);
            }
        }

        function calculateAutoMU() {
            try {
                if (!document.getElementById('calcular-mu-auto').checked || accelerometerData.z.length === 0) return;
                const maxDeceleration = Math.min(...accelerometerData.z);
                const g = 9.81;
                const mu = Math.abs(maxDeceleration / g);
                document.getElementById('mu-auto').innerText = mu.toFixed(3);
                console.log('풮 autom치tico calculado:', mu);
            } catch (error) {
                console.error('Error en calculateAutoMU:', error);
            }
        }

        function calculateManualMU() {
            try {
                if (!manualSelection.start || !manualSelection.end) return;
                const start = Math.min(manualSelection.start, manualSelection.end);
                const end = Math.max(manualSelection.start, manualSelection.end);
                const zData = accelerometerData.z.slice(start, end + 1);
                const avgDeceleration = zData.reduce((sum, val) => sum + val, 0) / zData.length;
                const g = 9.81;
                const mu = Math.abs(avgDeceleration / g);
                document.getElementById('mu-manual').innerText = mu.toFixed(3);
                console.log('풮 manual calculado:', mu);
            } catch (error) {
                console.error('Error en calculateManualMU:', error);
            }
        }

        function toggleManualSelection() {
            try {
                if (!document.getElementById('seleccionar-intervalo').checked) {
                    manualSelection = { start: null, end: null };
                    document.getElementById('selection-info').innerText = 'Haga clic en la gr치fica para seleccionar el tramo';
                    console.log('Selecci칩n manual desactivada');
                }
            } catch (error) {
                console.error('Error en toggleManualSelection:', error);
            }
        }

        // Generar hash SHA-256
        async function generateHash(data) {
            try {
                const msgBuffer = new TextEncoder().encode(data);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                console.error('Error en generateHash:', error);
                return 'N/A';
            }
        }

        // Grabaci칩n de datos
        document.getElementById('start-recording').addEventListener('click', () => {
            try {
                console.log('Iniciando grabaci칩n...');
                if (!window.DeviceMotionEvent || !navigator.geolocation) {
                    alert('Los sensores no est치n disponibles en este dispositivo.');
                    console.warn('Sensores no disponibles');
                    return;
                }
                document.getElementById('start-recording').disabled = true;
                document.getElementById('stop-recording').disabled = false;
                document.getElementById('recording-status').innerText = 'Grabando...';
                accelerometerData = { x: [], y: [], z: [], speed: [], time: [] };
                gpsData = { lat: [], lon: [], speed: [], accuracy: [], time: [] };
                isRecording = true;
                startGPS();
                console.log('Grabaci칩n iniciada');
            } catch (error) {
                console.error('Error al iniciar grabaci칩n:', error);
            }
        });

        document.getElementById('stop-recording').addEventListener('click', () => {
            try {
                console.log('Deteniendo grabaci칩n...');
                isRecording = false;
                navigator.geolocation.clearWatch(watchId);
                document.getElementById('start-recording').disabled = false;
                document.getElementById('stop-recording').disabled = true;
                document.getElementById('recording-status').innerText = 'Grabaci칩n finalizada';
                calculateAutoMU();
                console.log('Grabaci칩n detenida con', accelerometerData.time.length, 'puntos');
            } catch (error) {
                console.error('Error al detener grabaci칩n:', error);
            }
        });

        // Descarga de datos
        async function downloadAccelerometerData() {
            try {
                console.log('Exportando datos de aceler칩metro...');
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let csv = `N칰mero de diligencias,${diligencias}\nMatr칤cula,${matricula}\nFecha y hora,${now}\nDispositivo,${navigator.userAgent}\nFrecuencia de muestreo,10 Hz\n`;
                csv += 'Tiempo (s),Eje X (m/s),Eje Y (m/s),Eje Z (m/s),Velocidad (km/h)\n';
                for (let i = 0; i < accelerometerData.time.length; i++) {
                    csv += `${accelerometerData.time[i].toFixed(1)},${accelerometerData.x[i].toFixed(2)},${accelerometerData.y[i].toFixed(2)},${accelerometerData.z[i].toFixed(2)},${accelerometerData.speed[i].toFixed(1)}\n`;
                }
                const hash = await generateHash(csv);
                document.getElementById('mu-hash').innerText = hash;
                csv += `Hash SHA-256,${hash}\n`;
                const blob = new Blob([csv], { type: 'text/csv' });
                saveAs(blob, `acelerometro_${diligencias.replace(/[/\s]/g, '_')}.csv`);
                console.log('Datos de aceler칩metro exportados');
            } catch (error) {
                console.error('Error en downloadAccelerometerData:', error);
            }
        }

        async function downloadGPSData() {
            try {
                console.log('Exportando datos GPS...');
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let csv = `N칰mero de diligencias,${diligencias}\nMatr칤cula,${matricula}\nFecha y hora,${now}\nDispositivo,${navigator.userAgent}\n`;
                csv += 'Tiempo (s),Latitud,Longitud,Velocidad (km/h),Precisi칩n (m)\n';
                for (let i = 0; i < gpsData.time.length; i++) {
                    csv += `${gpsData.time[i].toFixed(1)},${gpsData.lat[i].toFixed(6)},${gpsData.lon[i].toFixed(6)},${gpsData.speed[i].toFixed(1)},${gpsData.accuracy[i].toFixed(1)}\n`;
                }
                const hash = await generateHash(csv);
                document.getElementById('mu-hash').innerText = hash;
                csv += `Hash SHA-256,${hash}\n`;
                const blob = new Blob([csv], { type: 'text/csv' });
                saveAs(blob, `gps_${diligencias.replace(/[/\s]/g, '_')}.csv`);
                console.log('Datos GPS exportados');
            } catch (error) {
                console.error('Error en downloadGPSData:', error);
            }
        }

        async function generatePDFReport() {
            try {
                console.log('Generando informe PDF...');
                if (!jsPDF) {
                    console.error('jsPDF no disponible');
                    alert('Error: No se pudo generar el PDF. Verifica la consola.');
                    return;
                }
                const doc = new jsPDF();
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let y = 20;

                doc.setFontSize(16);
                doc.text('Informe de An치lisis de Frenos', 105, y, { align: 'center' });
                y += 10;
                doc.setFontSize(12);
                doc.text(`N칰mero de diligencias: ${diligencias}`, 20, y);
                y += 7;
                doc.text(`Matr칤cula: ${matricula}`, 20, y);
                y += 7;
                doc.text(`Fecha y hora: ${now}`, 20, y);
                y += 7;
                doc.text(`Dispositivo: ${navigator.userAgent}`, 20, y);
                y += 10;

                doc.text('Datos de Aceler칩metro:', 20, y);
                y += 7;
                doc.autoTable({
                    startY: y,
                    head: [['Tiempo (s)', 'Eje X (m/s)', 'Eje Y (m/s)', 'Eje Z (m/s)', 'Velocidad (km/h)']],
                    body: accelerometerData.time.map((t, i) => [
                        t.toFixed(1),
                        accelerometerData.x[i].toFixed(2),
                        accelerometerData.y[i].toFixed(2),
                        accelerometerData.z[i].toFixed(2),
                        accelerometerData.speed[i].toFixed(1)
                    ]).slice(0, 10)
                });
                y = doc.lastAutoTable.finalY + 10;

                doc.text('Datos GPS:', 20, y);
                y += 7;
                doc.autoTable({
                    startY: y,
                    head: [['Tiempo (s)', 'Latitud', 'Longitud', 'Velocidad (km/h)', 'Precisi칩n (m)']],
                    body: gpsData.time.map((t, i) => [
                        t.toFixed(1),
                        gpsData.lat[i].toFixed(6),
                        gpsData.lon[i].toFixed(6),
                        gpsData.speed[i].toFixed(1),
                        gpsData.accuracy[i].toFixed(1)
                    ]).slice(0, 10)
                });
                y = doc.lastAutoTable.finalY + 10;

                doc.text(`풮 Autom치tico: ${document.getElementById('mu-auto').innerText}`, 20, y);
                y += 7;
                doc.text(`풮 Manual: ${document.getElementById('mu-manual').innerText}`, 20, y);
                y += 10;

                const hash = document.getElementById('mu-hash').innerText;
                doc.text(`Hash de integridad: ${hash}`, 20, y);
                y += 10;
                doc.text('Certificado por: An치lisis de Frenos', 20, y);
                doc.save(`informe_${diligencias.replace(/[/\s]/g, '_')}.pdf`);
                console.log('Informe PDF generado');
            } catch (error) {
                console.error('Error en generatePDFReport:', error);
            }
        }

        // Test de tiempo de reacci칩n
        let randomDelay = 0;
        let isTestRunning = false;
        let lightsOffTime = 0;
        let reactionTime = 0;

        function iniciarTestReaccion(event) {
            try {
                console.log('Iniciando test de reacci칩n...');
                event.stopPropagation();
                const luces = document.querySelectorAll('#reaccion .light');
                const area = document.querySelector('#reaction-area');
                const resultado = document.querySelector('#reaction-result');
                const explicacion = document.querySelector('#reaction-explanation');
                const startBtn = document.querySelector('#iniciar-test');
                const exportBtn = document.querySelector('#export-pdf');
                let indiceLuz = 1;

                isTestRunning = true;
                startBtn.disabled = true;
                exportBtn.disabled = true;
                resultado.innerText = '';
                explicacion.innerText = '';
                area.innerText = 'Prep치rate...';
                resultado.classList.remove('false-start');
                luces.forEach(luz => luz.classList.remove('encendida'));

                const intervaloLuces = setInterval(() => {
                    document.querySelectorAll(`.light[data-index="${indiceLuz}"]`).forEach(luz => luz.classList.add('encendida'));
                    indiceLuz++;
                    if (indiceLuz > 5) {
                        clearInterval(intervaloLuces);
                        randomDelay = Math.random() * (5000 - 500) + 500;
                        setTimeout(() => {
                            luces.forEach(luz => luz.classList.remove('encendida'));
                            area.innerText = '춰Toca ahora!';
                            lightsOffTime = performance.now();
                            capturarTiempoReaccion();
                            console.log('Luces apagadas, esperando reacci칩n');
                        }, randomDelay);
                    }
                }, 500);

                const falseStartHandler = event => {
                    if (isTestRunning && !lightsOffTime) {
                        isTestRunning = false;
                        clearInterval(intervaloLuces);
                        luces.forEach(luz => luz.classList.remove('encendida'));
                        resultado.innerText = 'False Start: Interacci칩n prematura detectada';
                        resultado.classList.add('false-start');
                        explicacion.innerText = 'El ensayo fue invalidado debido a una interacci칩n antes de la desactivaci칩n de los indicadores luminosos.';
                        startBtn.disabled = false;
                        area.removeEventListener('click', falseStartHandler);
                        area.removeEventListener('touchstart', falseStartHandler);
                        console.log('False start detectado');
                    }
                };

                setTimeout(() => {
                    area.addEventListener('click', falseStartHandler);
                    area.addEventListener('touchstart', falseStartHandler);
                }, 100);
            } catch (error) {
                console.error('Error en iniciarTestReaccion:', error);
            }
        }

        function capturarTiempoReaccion() {
            try {
                console.log('Configurando captura de tiempo de reacci칩n...');
                const area = document.querySelector('#reaction-area');
                const resultado = document.querySelector('#reaction-result');
                const explicacion = document.querySelector('#reaction-explanation');
                const startBtn = document.querySelector('#iniciar-test');
                const exportBtn = document.querySelector('#export-pdf');
                const diligencias = document.getElementById('reaccion-diligencias').value || 'N/A';
                const matricula = document.getElementById('reaccion-matricula').value || '';

                const captureReaction = async event => {
                    event.stopPropagation();
                    if (!isTestRunning) return;
                    isTestRunning = false;
                    reactionTime = (performance.now() - lightsOffTime) / 1000;
                    resultado.innerText = `Tiempo de reacci칩n: ${reactionTime.toFixed(3)} segundos`;
                    explicacion.innerHTML = `
                        <strong>Descripci칩n t칠cnica del ensayo:</strong><br>
                        El ensayo de tiempo de reacci칩n, conforme a los est치ndares de evaluaci칩n de respuesta humana (ISO 23274), consiste en la activaci칩n secuencial y acumulativa de cinco pares de indicadores luminosos rojos, con un intervalo de 0,500 segundos por par, emulando el sistema de se침alizaci칩n de un sem치foro de F칩rmula 1. Cada par de indicadores permanece encendido tras su activaci칩n. Tras la activaci칩n del 칰ltimo par, se introduce un intervalo aleatorio entre 0,500 y 5,000 segundos antes de la desactivaci칩n simult치nea de todos los indicadores. En este ensayo, el intervalo aleatorio fue de ${(randomDelay / 1000).toFixed(3)} segundos. El tiempo de reacci칩n se mide desde la desactivaci칩n de los indicadores hasta la interacci칩n del usuario con la pantalla t치ctil, con una precisi칩n de 췀1 milisegundo.<br><br>
                        <strong>Par치metros del ensayo:</strong><br>
                        - N칰mero de diligencias: ${diligencias}<br>
                        - Matr칤cula: ${matricula}<br>
                        - Fecha y hora: ${new Date().toLocaleString('es-ES')}<br>
                        - Dispositivo: ${navigator.userAgent}<br>
                        - Tiempo de reacci칩n registrado: ${reactionTime.toFixed(3)} segundos
                    `;
                    startBtn.disabled = false;
                    exportBtn.disabled = false;
                    area.innerText = 'Prep치rate para interactuar nuevamente';
                    const hash = await generateHash(
                        `N칰mero de diligencias,${diligencias}\nMatr칤cula,${matricula}\nFecha y hora,${new Date().toLocaleString('es-ES')}\nDispositivo,${navigator.userAgent}\nTiempo de reacci칩n (s),${reactionTime.toFixed(3)}\nIntervalo aleatorio (s),${(randomDelay / 1000).toFixed(3)}`
                    );
                    document.getElementById('reaction-hash').innerText = hash;
                    console.log('Tiempo de reacci칩n capturado:', reactionTime);
                    area.removeEventListener('click', captureReaction);
                    area.removeEventListener('touchstart', captureReaction);
                };

                area.addEventListener('click', captureReaction, { once: true });
                area.addEventListener('touchstart', captureReaction, { once: true });
            } catch (error) {
                console.error('Error en capturarTiempoReaccion:', error);
            }
        }

        async function exportReactionPDF() {
            try {
                console.log('Generando PDF de tiempo de reacci칩n...');
                if (!jsPDF) {
                    console.error('jsPDF no disponible');
                    alert('Error: No se pudo generar el PDF. Verifica la consola.');
                    return;
                }
                const doc = new jsPDF();
                const diligencias = document.getElementById('reaccion-diligencias').value || 'N/A';
                const matricula = document.getElementById('reaccion-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let y = 20;

                // A침adir 칤cono
                try {
                    const img = new Image();
                    img.src = '/icon.png';
                    await new Promise(resolve => {
                        img.onload = () => {
                            doc.addImage(img, 'PNG', 80, y, 50, 50);
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn('No se pudo cargar el 칤cono');
                            resolve();
                        };
                    });
                    y += 60;
                } catch (error) {
                    console.error('Error al a침adir 칤cono:', error);
                }

                // Encabezado
                doc.setFontSize(16);
                doc.text('Informe de Ensayo de Tiempo de Reacci칩n', 105, y, { align: 'center' });
                y += 10;
                doc.setFontSize(12);
                doc.text('An치lisis de Frenos - Sistema Judicial', 105, y, { align: 'center' });
                y += 10;

                // Metadatos
                doc.text(`N칰mero de diligencias: ${diligencias}`, 20, y);
                y += 7;
                doc.text(`Matr칤cula: ${matricula}`, 20, y);
                y += 7;
                doc.text(`Fecha y hora: ${now}`, 20, y);
                y += 7;
                doc.text(`Dispositivo: ${navigator.userAgent}`, 20, y);
                y += 10;

                // Descripci칩n t칠cnica
                doc.text('Descripci칩n t칠cnica del ensayo:', 20, y);
                y += 7;
                doc.setFontSize(10);
                doc.text(
                    'El ensayo de tiempo de reacci칩n, conforme a los est치ndares de evaluaci칩n de respuesta humana (ISO 23274), consiste en la activaci칩n secuencial y acumulativa de cinco pares de indicadores luminosos rojos, con un intervalo de 0,500 segundos por par, emulando el sistema de se침alizaci칩n de un sem치foro de F칩rmula 1. Cada par de indicadores permanece encendido tras su activaci칩n. Tras la activaci칩n del 칰ltimo par, se introduce un intervalo aleatorio entre 0,500 y 5,000 segundos antes de la desactivaci칩n simult치nea de todos los indicadores. En este ensayo, el intervalo aleatorio fue de ' + (randomDelay / 1000).toFixed(3) + ' segundos. El tiempo de reacci칩n se mide desde la desactivaci칩n de los indicadores hasta la interacci칩n del usuario con la pantalla t치ctil, con una precisi칩n de 췀1 milisegundo.',
                    20, y, { maxWidth: 170 }
                );
                y += 40;

                // Resultados
                doc.setFontSize(12);
                doc.text('Resultados del ensayo:', 20, y);
                y += 7;
                doc.autoTable({
                    startY: y,
                    head: [['Par치metro', 'Valor']],
                    body: [
                        ['Tiempo de reacci칩n (s)', reactionTime.toFixed(3)],
                        ['Intervalo aleatorio (s)', (randomDelay / 1000).toFixed(3)],
                        ['Hash SHA-256', document.getElementById('reaction-hash').innerText]
                    ]
                });
                y = doc.lastAutoTable.finalY + 10;

                // Certificaci칩n
                doc.text('Certificado por: An치lisis de Frenos', 20, y);
                y += 7;
                doc.setFontSize(8);
                doc.text('Este informe ha sido generado autom치ticamente por el sistema de An치lisis de Frenos para uso en procedimientos judiciales.', 20, y, { maxWidth: 170 });

                doc.save(`reaccion_${diligencias.replace(/[/\s]/g, '_')}.pdf`);
                console.log('PDF de reacci칩n exportado');
            } catch (error) {
                console.error('Error en exportReactionPDF:', error);
            }
        }

        // Iniciar el test
        document.getElementById('iniciar-test').addEventListener('click', iniciarTestReaccion);
        document.getElementById('export-pdf').addEventListener('click', exportReactionPDF);

        // Inicializar nivel al cargar
        try {
            initBubbleLevel();
        } catch (error) {
            console.error('Error al inicializar nivel al cargar:', error);
        }

        // Registrar Service Worker (deshabilitado para depuraci칩n)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(() => console.log('Service Worker registrado'))
                .catch(err => console.error('Error al registrar Service Worker:', err));
        }
        */
    </script>
</body>
</html>