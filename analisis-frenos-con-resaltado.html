<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Análisis de Frenos - Sistema Judicial</title>
    <link rel="manifest" href="manifest.json">
    <style>
        html {
            font-size: 16px;
        }
        body {
            font-family: 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ebedef;
            color: #333;
            overscroll-behavior: none;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 1rem;
        }
        header {
            background-color: #2c3e50;
            color: #fff;
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header img {
            height: 2.5rem;
        }
        header .metadata {
            font-size: 0.9rem;
        }
        .tabs {
            display: flex;
            background-color: #34495e;
            border-radius: 0.5rem 0.5rem 0 0;
            flex-wrap: wrap;
        }
        .tab {
            flex: 1;
            padding: 0.8rem;
            text-align: center;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 1rem;
        }
        .tab.active {
            background-color: #3498db;
        }
        .tab-content {
            display: none;
            background-color: #fff;
            padding: 1rem;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1);
        }
        .tab-content.active {
            display: block;
        }
        button {
            padding: 0.8rem 1.5rem;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.3rem;
            transition: background-color 0.3s;
            min-height: 44px;
            touch-action: manipulation;
        }
        button:hover:not(:disabled) {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .input-group {
            margin: 0.8rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .input-group label {
            width: 9rem;
            font-weight: bold;
            font-size: 0.9rem;
        }
        .input-group input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
            width: 100%;
            max-width: 20rem;
            font-size: 0.9rem;
        }
        .checkbox-group {
            margin: 0.8rem 0;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .checkbox-group label {
            font-size: 0.9rem;
        }
        .status {
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .validation-seal {
            margin: 1rem 0;
            padding: 0.6rem;
            background-color: #e8f8e8;
            border-left: 0.25rem solid #2ecc71;
            font-size: 0.8rem;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 1rem;
            border-radius: 0.5rem;
            max-width: 90%;
            text-align: center;
            font-size: 0.9rem;
        }
        .graph-container {
            margin: 1rem 0;
            padding: 0.6rem;
            background-color: #f9f9f9;
            border-radius: 0.5rem;
            width: 100%;
            height: 40vh;
        }
        #mu-graph {
            width: 100% !important;
            height: 100% !important;
        }
        #reaccion {
            background-color: #1c2526;
            color: #fff;
            border-radius: 0.5rem;
            padding: 1.5rem;
        }
        .lights-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin: 1.5rem 0;
        }
        .lights-row {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .light {
            width: 15vmin;
            height: 15vmin;
            border-radius: 50%;
            background-color: #4a4a4a;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .light.encendida {
            background-color: #ff0000;
            box-shadow: 0 0 2rem rgba(255, 0, 0, 0.8), 0 0 0.6rem rgba(255, 255, 255, 0.5);
        }
        .reaction-area {
            width: 100%;
            height: 30vh;
            background-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #fff;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            touch-action: manipulation;
        }
        .reaction-result, .reaction-explanation {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            line-height: 1.6;
            animation: fadeIn 0.5s ease-in;
        }
        .reaction-result.false-start {
            color: #e74c3c;
            font-weight: bold;
        }
        #iniciar-test {
            padding: 0.9rem 2rem;
            font-size: 1.1rem;
            background-color: #e74c3c;
        }
        #iniciar-test:hover:not(:disabled) {
            background-color: #c0392b;
        }
        .bubble-level-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
            position: relative;
            width: 80vw;
            height: 80vw;
            max-width: 300px;
            max-height: 300px;
            background-color: #f0f0f0;
            border: 2px solid #333;
            border-radius: 0.5rem;
        }
        #bubble-level {
            width: 100%;
            height: 100%;
        }
        .bubble-status {
            margin-top: 1rem;
            font-size: 1rem;
            font-weight: bold;
        }
        .bubble-status.levelled {
            color: #2ecc71;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @media (max-width: 768px) {
            html { font-size: 14px; }
            .tabs { flex-direction: column; }
            .tab { padding: 0.6rem; font-size: 0.9rem; }
            .input-group { flex-direction: column; align-items: flex-start; }
            .input-group label { width: 100%; }
            .input-group input { max-width: 100%; }
            .checkbox-group { flex-direction: column; gap: 0.5rem; }
            .graph-container { height: 35vh; }
            .light { width: 12vmin; height: 12vmin; }
            .lights-row { gap: 0.5rem; }
            .reaction-area { height: 25vh; font-size: 1.2rem; }
            button { padding: 0.6rem 1rem; font-size: 0.9rem; }
            .bubble-level-container { width: 70vw; height: 70vw; max-width: 250px; max-height: 250px; }
        }
        @media (max-width: 480px) {
            html { font-size: 12px; }
            .container { padding: 0.5rem; }
            header { padding: 0.5rem; }
            header img { height: 2rem; }
            .light { width: 10vmin; height: 10vmin; }
            .reaction-area { font-size: 1rem; }
            .modal-content { max-width: 95%; }
            .bubble-level-container { width: 60vw; height: 60vw; max-width: 200px; max-height: 200px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <img src="https://via.placeholder.com/150x40?text=Logo" alt="Logo">
        <div class="metadata">
            <span id="current-datetime"></span> | Versión 1.0.0
        </div>
    </header>
    <div class="container">
        <h1>Análisis de Frenos - Sistema Judicial</h1>
        <div class="tabs">
            <div class="tab active" onclick="openTab('nivel')">Nivel</div>
            <div class="tab" onclick="openTab('mu')">Análisis μ</div>
            <div class="tab" onclick="openTab('reaccion')">Tiempo de Reacción</div>
        </div>

        <div id="nivel" class="tab-content active">
            <h2>Nivel de Inclinación</h2>
            <div class="bubble-level-container">
                <canvas id="bubble-level"></canvas>
            </div>
            <p class="bubble-status" id="bubble-status">Ajuste el dispositivo para nivelar</p>
            <button onclick="calibrateSensors()">Calibrar Sensores</button>
            <p class="status">Estado: <span id="sensor-status">Esperando calibración</span></p>
        </div>

        <div id="mu" class="tab-content">
            <h2>Análisis del Coeficiente de Rozamiento (μ)</h2>
            <div class="input-group">
                <label>Número de diligencias:</label>
                <input type="text" id="mu-diligencias" placeholder="Ej: 1234/2025">
                <label>Matrícula:</label>
                <input type="text" id="mu-matricula" placeholder="Ej: ABC1234">
            </div>
            <button id="start-recording">Iniciar Grabación</button>
            <button id="stop-recording" disabled>Detener Grabación</button>
            <p><strong>Estado:</strong> <span id="recording-status">No grabando</span></p>
            <p><strong>Estado GPS:</strong> <span id="gps-status">📍 Esperando señal</span></p>
            <p><strong>Coordenadas:</strong> <span id="gps-coords">N/A</span></p>
            <p><strong>Velocidad GPS:</strong> <span id="gps-speed">0.0 km/h</span></p>
            <p><strong>Precisión GPS:</strong> <span id="gps-accuracy">N/A</span></p>
            <p><strong>Puntos GPS:</strong> <span id="gps-points">0</span></p>
            <div class="checkbox-group">
                <label><input type="checkbox" id="show-eje-x" checked onchange="updateGraph()"> Eje X</label>
                <label><input type="checkbox" id="show-eje-y" checked onchange="updateGraph()"> Eje Y</label>
                <label><input type="checkbox" id="show-eje-z" checked onchange="updateGraph()"> Eje Z</label>
                <label><input type="checkbox" id="show-velocidad" checked onchange="updateGraph()"> Velocidad</label>
            </div>
            <div class="graph-container">
                <canvas id="mu-graph"></canvas>
            </div>
            <p><strong>μ Automático:</strong> <span id="mu-auto">0.000</span></p>
            <p><strong>μ Manual:</strong> <span id="mu-manual">0.000</span></p>
            <p class="status">Selección: <span id="selection-info">Haga clic en la gráfica para seleccionar el tramo</span></p>
            <button onclick="downloadAccelerometerData()">Exportar Datos Acelerómetro (CSV)</button>
            <button onclick="downloadGPSData()">Exportar Datos GPS (CSV)</button>
            <button onclick="generatePDFReport()">Generar Informe PDF</button>
            <div class="validation-seal">Datos certificados por Análisis de Frenos | Hash: <span id="mu-hash">N/A</span></div>
            <p>
                <input type="checkbox" id="calcular-mu-auto" checked onchange="calculateAutoMU()"> Cálculo Automático de μ<br>
                <input type="checkbox" id="seleccionar-intervalo" onchange="toggleManualSelection()"> Selección Manual de Tramo
            </p>
        </div>

        <div id="reaccion" class="tab-content">
            <h2>Ensayo de Tiempo de Reacción</h2>
            <div class="input-group">
                <label>Número de diligencias:</label>
                <input type="text" id="reaccion-diligencias" placeholder="Ej: 1234/2025">
                <label>Matrícula:</label>
                <input type="text" id="reaccion-matricula" placeholder="Ej: ABC1234">
            </div>
            <div class="lights-wrapper">
                <div class="lights-row">
                    <div class="light" data-index="1"></div>
                    <div class="light" data-index="2"></div>
                    <div class="light" data-index="3"></div>
                    <div class="light" data-index="4"></div>
                    <div class="light" data-index="5"></div>
                </div>
                <div class="lights-row">
                    <div class="light" data-index="1"></div>
                    <div class="light" data-index="2"></div>
                    <div class="light" data-index="3"></div>
                    <div class="light" data-index="4"></div>
                    <div class="light" data-index="5"></div>
                </div>
            </div>
            <button id="iniciar-test">Iniciar Ensayo</button>
            <button id="capture-screenshot" disabled>Exportar Captura</button>
            <div class="reaction-area" id="reaction-area">Prepárate para interactuar cuando las luces se apaguen</div>
            <div class="reaction-result" id="reaction-result"></div>
            <div class="reaction-explanation" id="reaction-explanation"></div>
            <div class="validation-seal">Datos certificados por Análisis de Frenos | Hash: <span id="reaction-hash">N/A</span></div>
        </div>

        <div class="modal" id="tutorial-modal">
            <div class="modal-content">
                <h2>Bienvenido al Sistema de Análisis de Frenos</h2>
                <p>Esta aplicación realiza ensayos precisos para determinar el coeficiente de rozamiento (μ) y el tiempo de reacción, diseñada para uso en procedimientos judiciales.</p>
                <p><strong>Instrucciones:</strong></p>
                <ul>
                    <li>Nivele el dispositivo en la pestaña "Nivel" hasta que la burbuja sea verde.</li>
                    <li>En "Análisis μ", inicie la grabación para capturar datos de frenado.</li>
                    <li>En "Tiempo de Reacción", realice el ensayo tocando la pantalla tras el apagado de las luces.</li>
                    <li>Exporte los datos en CSV o PDF para su uso en informes judiciales.</li>
                </ul>
                <button onclick="document.getElementById('tutorial-modal').style.display='none'">Entendido</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.0/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script>
        console.log('Iniciando script...');
        const { jsPDF } = window.jspdf || {};
        if (!window.Chart || !window.html2canvas || !window.saveAs || !jsPDF) {
            console.error('Error: Alguna dependencia (Chart.js, html2canvas, FileSaver, jsPDF) no se cargó correctamente');
        }

        let accelerometerData = { x: [], y: [], z: [], speed: [], time: [] };
        let gpsData = { lat: [], lon: [], speed: [], accuracy: [], time: [] };
        let isRecording = false;
        let manualSelection = { start: null, end: null };
        let calibration = { x: 0, y: 0, z: 9.81, angleX: 0, angleY: 0 };
        let watchId = null;
        let isLevelled = false;

        // Actualizar fecha y hora
        function updateDateTime() {
            try {
                const now = new Date();
                document.getElementById('current-datetime').textContent = now.toLocaleString('es-ES', { timeZone: 'Europe/Madrid' });
            } catch (error) {
                console.error('Error en updateDateTime:', error);
            }
        }
        setInterval(updateDateTime, 1000);
        updateDateTime();

        // Mostrar tutorial al cargar
        try {
            document.getElementById('tutorial-modal').style.display = 'flex';
        } catch (error) {
            console.error('Error al mostrar modal:', error);
        }

        // Gestión de pestañas
        function openTab(tabId) {
            try {
                console.log('Abriendo pestaña:', tabId);
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                const tabElement = document.querySelector(`[onclick="openTab('${tabId}')"]`);
                const contentElement = document.getElementById(tabId);
                if (!tabElement || !contentElement) {
                    console.error('Elemento no encontrado para tabId:', tabId);
                    return;
                }
                tabElement.classList.add('active');
                contentElement.classList.add('active');
                if (tabId === 'nivel') {
                    initBubbleLevel();
                }
            } catch (error) {
                console.error('Error en openTab:', error);
            }
        }

        // Configuración del nivel de burbuja
        const bubbleCanvas = document.getElementById('bubble-level');
        const bubbleCtx = bubbleCanvas ? bubbleCanvas.getContext('2d') : null;
        let bubbleRadius = 15;

        function initBubbleLevel() {
            try {
                console.log('Inicializando nivel de burbuja...');
                if (!bubbleCanvas || !bubbleCtx) {
                    console.error('Error: Canvas o contexto no disponible');
                    document.getElementById('bubble-status').innerText = 'Canvas no disponible';
                    return;
                }
                resizeBubbleCanvas();
                window.addEventListener('resize', resizeBubbleCanvas);
                window.addEventListener('orientationchange', resizeBubbleCanvas);
            } catch (error) {
                console.error('Error en initBubbleLevel:', error);
            }
        }

        function resizeBubbleCanvas() {
            try {
                const container = document.querySelector('.bubble-level-container');
                if (!container || !bubbleCanvas) {
                    console.error('Error: Container o canvas no encontrado');
                    return;
                }
                bubbleCanvas.width = container.clientWidth;
                bubbleCanvas.height = container.clientHeight;
                bubbleRadius = Math.min(bubbleCanvas.width, bubbleCanvas.height) / 20;
                console.log('Canvas redimensionado:', bubbleCanvas.width, bubbleCanvas.height);
                drawBubble();
            } catch (error) {
                console.error('Error en resizeBubbleCanvas:', error);
            }
        }

        function drawBubble() {
            try {
                if (!bubbleCtx) {
                    console.error('Error: Contexto del canvas no disponible');
                    return;
                }
                bubbleCtx.clearRect(0, 0, bubbleCanvas.width, bubbleCanvas.height);
                bubbleCtx.beginPath();
                bubbleCtx.strokeStyle = '#666';
                bubbleCtx.lineWidth = 1;
                bubbleCtx.moveTo(bubbleCanvas.width / 2, 0);
                bubbleCtx.lineTo(bubbleCanvas.width / 2, bubbleCanvas.height);
                bubbleCtx.moveTo(0, bubbleCanvas.height / 2);
                bubbleCtx.lineTo(bubbleCanvas.width, bubbleCanvas.height / 2);
                bubbleCtx.stroke();
                const maxTilt = 10;
                let angleX = calibration.angleX || 0;
                let angleY = calibration.angleY || 0;
                const centerX = bubbleCanvas.width / 2;
                const centerY = bubbleCanvas.height / 2;
                const maxOffset = (bubbleCanvas.width / 2) - bubbleRadius;
                const offsetX = (angleX / maxTilt) * maxOffset;
                const offsetY = (angleY / maxTilt) * maxOffset;
                bubbleCtx.beginPath();
                bubbleCtx.arc(centerX + offsetX, centerY + offsetY, bubbleRadius, 0, 2 * Math.PI);
                bubbleCtx.fillStyle = isLevelled ? '#2ecc71' : '#e74c3c';
                bubbleCtx.fill();
                bubbleCtx.strokeStyle = '#333';
                bubbleCtx.lineWidth = 2;
                bubbleCtx.stroke();
                console.log('Burbuja dibujada:', { angleX, angleY, isLevelled });
            } catch (error) {
                console.error('Error en drawBubble:', error);
            }
        }

        // Calibración de sensores
        function calibrateSensors() {
            try {
                console.log('Calibrando sensores...');
                document.getElementById('sensor-status').innerText = 'Calibrando...';
                window.addEventListener('devicemotion', function handler(event) {
                    calibration.x = event.accelerationIncludingGravity?.x || 0;
                    calibration.y = event.accelerationIncludingGravity?.y || 0;
                    calibration.z = event.accelerationIncludingGravity?.z || 9.81;
                    document.getElementById('sensor-status').innerText = 'Calibración completada';
                    console.log('Calibración completada:', calibration);
                    initBubbleLevel();
                    window.removeEventListener('devicemotion', handler);
                }, { passive: true, once: true });
            } catch (error) {
                console.error('Error en calibrateSensors:', error);
                document.getElementById('sensor-status').innerText = 'Error al calibrar';
            }
        }

        // Verificar compatibilidad de sensores
        if (!window.DeviceMotionEvent) {
            console.warn('DeviceMotionEvent no soportado');
            document.getElementById('bubble-status').innerText = 'Sensores de movimiento no soportados';
            document.getElementById('sensor-status').innerText = 'Sensores no disponibles';
        } else {
            window.addEventListener('devicemotion', event => {
                try {
                    const x = (event.accelerationIncludingGravity?.x || 0) - calibration.x;
                    const y = (event.accelerationIncludingGravity?.y || 0) - calibration.y;
                    const z = (event.accelerationIncludingGravity?.z || 0) - calibration.z;
                    calibration.angleX = Math.atan2(y, z) * (180 / Math.PI);
                    calibration.angleY = Math.atan2(x, z) * (180 / Math.PI);
                    isLevelled = Math.abs(calibration.angleX) < 0.5 && Math.abs(calibration.angleY) < 0.5;
                    document.getElementById('bubble-status').innerText = isLevelled ? '✓ Nivelado' : 'Ajuste el dispositivo';
                    document.getElementById('bubble-status').classList.toggle('levelled', isLevelled);
                    drawBubble();
                    console.log('DeviceMotion:', { x, y, z, angleX: calibration.angleX, angleY: calibration.angleY, isLevelled });
                    if (isRecording) {
                        const time = performance.now() / 1000;
                        accelerometerData.x.push(x);
                        accelerometerData.y.push(y);
                        accelerometerData.z.push(z);
                        accelerometerData.speed.push(gpsData.speed[gpsData.speed.length - 1] || 0);
                        accelerometerData.time.push(time);
                        updateGraph();
                        calculateAutoMU();
                    }
                } catch (error) {
                    console.error('Error en DeviceMotionEvent:', error);
                }
            }, { passive: false });
        }

        // Captura de datos GPS
        function startGPS() {
            try {
                console.log('Iniciando GPS...');
                if (!navigator.geolocation) {
                    console.warn('Geolocation no soportado');
                    document.getElementById('gps-status').innerText = 'GPS no soportado';
                    return;
                }
                watchId = navigator.geolocation.watchPosition(
                    position => {
                        const time = performance.now() / 1000;
                        gpsData.lat.push(position.coords.latitude);
                        gpsData.lon.push(position.coords.longitude);
                        gpsData.speed.push(position.coords.speed ? position.coords.speed * 3.6 : 0);
                        gpsData.accuracy.push(position.coords.accuracy);
                        gpsData.time.push(time);
                        document.getElementById('gps-coords').innerText = `${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`;
                        document.getElementById('gps-speed').innerText = `${(position.coords.speed * 3.6).toFixed(1)} km/h`;
                        document.getElementById('gps-accuracy').innerText = `${position.coords.accuracy.toFixed(1)} m`;
                        document.getElementById('gps-points').innerText = gpsData.time.length;
                        document.getElementById('gps-status').innerText = '📍 Señal activa';
                        console.log('GPS actualizado:', { lat: position.coords.latitude, lon: position.coords.longitude });
                    },
                    error => {
                        console.error('Error GPS:', error.message);
                        document.getElementById('gps-status').innerText = `Error GPS: ${error.message}`;
                    },
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
            } catch (error) {
                console.error('Error en startGPS:', error);
            }
        }

        // Gráfica de Análisis μ
        let muChart = null;
        try {
            const ctx = document.getElementById('mu-graph').getContext('2d');
            muChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Eje X (m/s²)', data: [], borderColor: '#e74c3c', hidden: false },
                        { label: 'Eje Y (m/s²)', data: [], borderColor: '#3498db', hidden: false },
                        { label: 'Eje Z (m/s²)', data: [], borderColor: '#2ecc71', hidden: false },
                        { label: 'Velocidad (km/h)', data: [], borderColor: '#f1c40f', hidden: false },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: false } },
                    plugins: {
                        title: { display: true, text: 'Datos de Frenado en Tiempo Real', font: { size: 1.2 * 16 } }
                    },
                    onClick: (event, elements, chart) => {
                        try {
                            if (document.getElementById('seleccionar-intervalo').checked) {
                                const xValue = chart.scales.x.getValueForPixel(event.offsetX);
                                if (!manualSelection.start) {
                                    manualSelection.start = Math.floor(xValue);
                                    document.getElementById('selection-info').innerText = `Inicio: ${manualSelection.start}. Seleccione el fin.`;
                                } else if (!manualSelection.end) {
                                    manualSelection.end = Math.floor(xValue);
                                    document.getElementById('selection-info').innerText = `Tramo: ${manualSelection.start} a ${manualSelection.end}`;
                                    calculateManualMU();
                                } else {
                                    manualSelection = { start: null, end: null };
                                    document.getElementById('selection-info').innerText = 'Haga clic en la gráfica para seleccionar el tramo';
                                }
                                console.log('Selección en gráfica:', manualSelection);
                            }
                        } catch (error) {
                            console.error('Error en onClick de gráfica:', error);
                        }
                    }
                }
            });
            console.log('Gráfica inicializada');
        } catch (error) {
            console.error('Error al inicializar gráfica:', error);
        }

        function updateGraph() {
            try {
                if (!muChart) {
                    console.error('Error: Gráfica no inicializada');
                    return;
                }
                muChart.data.labels = accelerometerData.time;
                muChart.data.datasets[0].data = accelerometerData.x;
                muChart.data.datasets[1].data = accelerometerData.y;
                muChart.data.datasets[2].data = accelerometerData.z;
                muChart.data.datasets[3].data = accelerometerData.speed;
                muChart.data.datasets[0].hidden = !document.getElementById('show-eje-x').checked;
                muChart.data.datasets[1].hidden = !document.getElementById('show-eje-y').checked;
                muChart.data.datasets[2].hidden = !document.getElementById('show-eje-z').checked;
                muChart.data.datasets[3].hidden = !document.getElementById('show-velocidad').checked;
                muChart.update();
                console.log('Gráfica actualizada');
            } catch (error) {
                console.error('Error en updateGraph:', error);
            }
        }

        function calculateAutoMU() {
            try {
                if (!document.getElementById('calcular-mu-auto').checked || accelerometerData.z.length === 0) return;
                const maxDeceleration = Math.min(...accelerometerData.z);
                const g = 9.81;
                const mu = Math.abs(maxDeceleration / g);
                document.getElementById('mu-auto').innerText = mu.toFixed(3);
                console.log('μ automático calculado:', mu);
            } catch (error) {
                console.error('Error en calculateAutoMU:', error);
            }
        }

        function calculateManualMU() {
            try {
                if (!manualSelection.start || !manualSelection.end) return;
                const start = Math.min(manualSelection.start, manualSelection.end);
                const end = Math.max(manualSelection.start, manualSelection.end);
                const zData = accelerometerData.z.slice(start, end + 1);
                const avgDeceleration = zData.reduce((sum, val) => sum + val, 0) / zData.length;
                const g = 9.81;
                const mu = Math.abs(avgDeceleration / g);
                document.getElementById('mu-manual').innerText = mu.toFixed(3);
                console.log('μ manual calculado:', mu);
            } catch (error) {
                console.error('Error en calculateManualMU:', error);
            }
        }

        function toggleManualSelection() {
            try {
                if (!document.getElementById('seleccionar-intervalo').checked) {
                    manualSelection = { start: null, end: null };
                    document.getElementById('selection-info').innerText = 'Haga clic en la gráfica para seleccionar el tramo';
                    console.log('Selección manual desactivada');
                }
            } catch (error) {
                console.error('Error en toggleManualSelection:', error);
            }
        }

        // Generar hash SHA-256
        async function generateHash(data) {
            try {
                const msgBuffer = new TextEncoder().encode(data);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                console.error('Error en generateHash:', error);
                return 'N/A';
            }
        }

        // Grabación de datos
        document.getElementById('start-recording').addEventListener('click', () => {
            try {
                console.log('Iniciando grabación...');
                if (!isLevelled) {
                    alert('Por favor, nivela el dispositivo en la pestaña "Nivel" antes de iniciar la grabación.');
                    console.warn('Grabación bloqueada: Dispositivo no nivelado');
                    return;
                }
                if (!window.DeviceMotionEvent || !navigator.geolocation) {
                    alert('Los sensores no están disponibles en este dispositivo.');
                    console.warn('Sensores no disponibles');
                    return;
                }
                document.getElementById('start-recording').disabled = true;
                document.getElementById('stop-recording').disabled = false;
                document.getElementById('recording-status').innerText = 'Grabando...';
                accelerometerData = { x: [], y: [], z: [], speed: [], time: [] };
                gpsData = { lat: [], lon: [], speed: [], accuracy: [], time: [] };
                isRecording = true;
                startGPS();
                console.log('Grabación iniciada');
            } catch (error) {
                console.error('Error al iniciar grabación:', error);
            }
        });

        document.getElementById('stop-recording').addEventListener('click', () => {
            try {
                console.log('Deteniendo grabación...');
                isRecording = false;
                navigator.geolocation.clearWatch(watchId);
                document.getElementById('start-recording').disabled = false;
                document.getElementById('stop-recording').disabled = true;
                document.getElementById('recording-status').innerText = 'Grabación finalizada';
                calculateAutoMU();
                console.log('Grabación detenida');
            } catch (error) {
                console.error('Error al detener grabación:', error);
            }
        });

        // Descarga de datos
        async function downloadAccelerometerData() {
            try {
                console.log('Exportando datos de acelerómetro...');
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let csv = `Número de diligencias,${diligencias}\nMatrícula,${matricula}\nFecha y hora,${now}\nDispositivo,${navigator.userAgent}\nFrecuencia de muestreo,10 Hz\n`;
                csv += 'Tiempo (s),Eje X (m/s²),Eje Y (m/s²),Eje Z (m/s²),Velocidad (km/h)\n';
                for (let i = 0; i < accelerometerData.time.length; i++) {
                    csv += `${accelerometerData.time[i].toFixed(1)},${accelerometerData.x[i].toFixed(2)},${accelerometerData.y[i].toFixed(2)},${accelerometerData.z[i].toFixed(2)},${accelerometerData.speed[i].toFixed(1)}\n`;
                }
                const hash = await generateHash(csv);
                document.getElementById('mu-hash').innerText = hash;
                csv += `Hash SHA-256,${hash}\n`;
                const blob = new Blob([csv], { type: 'text/csv' });
                saveAs(blob, `acelerometro_${diligencias.replace(/[/\s]/g, '_')}.csv`);
                console.log('Datos de acelerómetro exportados');
            } catch (error) {
                console.error('Error en downloadAccelerometerData:', error);
            }
        }

        async function downloadGPSData() {
            try {
                console.log('Exportando datos GPS...');
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let csv = `Número de diligencias,${diligencias}\nMatrícula,${matricula}\nFecha y hora,${now}\nDispositivo,${navigator.userAgent}\n`;
                csv += 'Tiempo (s),Latitud,Longitud,Velocidad (km/h),Precisión (m)\n';
                for (let i = 0; i < gpsData.time.length; i++) {
                    csv += `${gpsData.time[i].toFixed(1)},${gpsData.lat[i].toFixed(6)},${gpsData.lon[i].toFixed(6)},${gpsData.speed[i].toFixed(1)},${gpsData.accuracy[i].toFixed(1)}\n`;
                }
                const hash = await generateHash(csv);
                document.getElementById('mu-hash').innerText = hash;
                csv += `Hash SHA-256,${hash}\n`;
                const blob = new Blob([csv], { type: 'text/csv' });
                saveAs(blob, `gps_${diligencias.replace(/[/\s]/g, '_')}.csv`);
                console.log('Datos GPS exportados');
            } catch (error) {
                console.error('Error en downloadGPSData:', error);
            }
        }

        async function generatePDFReport() {
            try {
                console.log('Generando informe PDF...');
                if (!jsPDF) {
                    console.error('jsPDF no disponible');
                    alert('Error: No se pudo generar el PDF. Verifica la consola.');
                    return;
                }
                const doc = new jsPDF();
                const diligencias = document.getElementById('mu-diligencias').value || 'N/A';
                const matricula = document.getElementById('mu-matricula').value || 'N/A';
                const now = new Date().toLocaleString('es-ES');
                let y = 20;

                doc.setFontSize(16);
                doc.text('Informe de Análisis de Frenos', 105, y, { align: 'center' });
                y += 10;
                doc.setFontSize(12);
                doc.text(`Número de diligencias: ${diligencias}`, 20, y);
                y += 7;
                doc.text(`Matrícula: ${matricula}`, 20, y);
                y += 7;
                doc.text(`Fecha y hora: ${now}`, 20, y);
                y += 7;
                doc.text(`Dispositivo: ${navigator.userAgent}`, 20, y);
                y += 10;

                doc.text('Datos de Acelerómetro:', 20, y);
                y += 7;
                doc.autoTable({
                    startY: y,
                    head: [['Tiempo (s)', 'Eje X (m/s²)', 'Eje Y (m/s²)', 'Eje Z (m/s²)', 'Velocidad (km/h)']],
                    body: accelerometerData.time.map((t, i) => [
                        t.toFixed(1),
                        accelerometerData.x[i].toFixed(2),
                        accelerometerData.y[i].toFixed(2),
                        accelerometerData.z[i].toFixed(2),
                        accelerometerData.speed[i].toFixed(1)
                    ]).slice(0, 10)
                });
                y = doc.lastAutoTable.finalY + 10;

                doc.text('Datos GPS:', 20, y);
                y += 7;
                doc.autoTable({
                    startY: y,
                    head: [['Tiempo (s)', 'Latitud', 'Longitud', 'Velocidad (km/h)', 'Precisión (m)']],
                    body: gpsData.time.map((t, i) => [
                        t.toFixed(1),
                        gpsData.lat[i].toFixed(6),
                        gpsData.lon[i].toFixed(6),
                        gpsData.speed[i].toFixed(1),
                        gpsData.accuracy[i].toFixed(1)
                    ]).slice(0, 10)
                });
                y = doc.lastAutoTable.finalY + 10;

                doc.text(`μ Automático: ${document.getElementById('mu-auto').innerText}`, 20, y);
                y += 7;
                doc.text(`μ Manual: ${document.getElementById('mu-manual').innerText}`, 20, y);
                y += 10;

                const hash = document.getElementById('mu-hash').innerText;
                doc.text(`Hash de integridad: ${hash}`, 20, y);
                y += 10;
                doc.text('Certificado por: Análisis de Frenos', 20, y);
                doc.save(`informe_${diligencias.replace(/[/\s]/g, '_')}.pdf`);
                console.log('Informe PDF generado');
            } catch (error) {
                console.error('Error en generatePDFReport:', error);
            }
        }

        // Test de tiempo de reacción
        let randomDelay = 0;
        let isTestRunning = false;
        let lightsOffTime = 0;

        function iniciarTestReaccion(event) {
            try {
                console.log('Iniciando test de reacción...');
                event.stopPropagation();
                const luces = document.querySelectorAll('#reaccion .light');
                const area = document.querySelector('#reaction-area');
                const resultado = document.querySelector('#reaction-result');
                const explicacion = document.querySelector('#reaction-explanation');
                const startBtn = document.querySelector('#iniciar-test');
                const captureBtn = document.querySelector('#capture-screenshot');
                let indiceLuz = 1;

                isTestRunning = true;
                startBtn.disabled = true;
                captureBtn.disabled = true;
                resultado.innerText = '';
                explicacion.innerText = '';
                area.innerText = 'Prepárate...';
                resultado.classList.remove('false-start');
                luces.forEach(luz => luz.classList.remove('encendida'));

                const intervaloLuces = setInterval(() => {
                    document.querySelectorAll(`.light[data-index="${indiceLuz}"]`).forEach(luz => luz.classList.add('encendida'));
                    indiceLuz++;
                    if (indiceLuz > 5) {
                        clearInterval(intervaloLuces);
                        randomDelay = Math.random() * (5000 - 500) + 500;
                        setTimeout(() => {
                            luces.forEach(luz => luz.classList.remove('encendida'));
                            area.innerText = '¡Toca ahora!';
                            lightsOffTime = performance.now();
                            capturarTiempoReaccion();
                            console.log('Luces apagadas, esperando reacción');
                        }, randomDelay);
                    }
                }, 500);

                const falseStartHandler = event => {
                    if (isTestRunning && !lightsOffTime) {
                        isTestRunning = false;
                        clearInterval(intervaloLuces);
                        luces.forEach(luz => luz.classList.remove('encendida'));
                        resultado.innerText = 'False Start: Interacción prematura detectada';
                        resultado.classList.add('false-start');
                        explicacion.innerText = 'El ensayo fue invalidado debido a una interacción antes de la desactivación de los indicadores luminosos.';
                        startBtn.disabled = false;
                        area.removeEventListener('click', falseStartHandler);
                        area.removeEventListener('touchstart', falseStartHandler);
                        console.log('False start detectado');
                    }
                };

                setTimeout(() => {
                    area.addEventListener('click', falseStartHandler);
                    area.addEventListener('touchstart', falseStartHandler);
                }, 100);
            } catch (error) {
                console.error('Error en iniciarTestReaccion:', error);
            }
        }

        function capturarTiempoReaccion() {
            try {
                console.log('Configurando captura de tiempo de reacción...');
                const area = document.querySelector('#reaction-area');
                const resultado = document.querySelector('#reaction-result');
                const explicacion = document.querySelector('#reaction-explanation');
                const startBtn = document.querySelector('#iniciar-test');
                const captureBtn = document.querySelector('#capture-screenshot');
                const diligencias = document.getElementById('reaccion-diligencias').value || 'N/A';
                const matricula = document.getElementById('reaccion-matricula').value || '';

                const captureReaction = async event => {
                    event.stopPropagation();
                    if (!isTestRunning) return;
                    isTestRunning = false;
                    const tiempoReaccion = (performance.now() - lightsOffTime) / 1000;
                    resultado.innerText = `Tiempo de reacción: ${tiempoReaccion.toFixed(3)} segundos`;
                    explicacion.innerHTML = `
                        <strong>Descripción técnica del ensayo:</strong><br>
                        El ensayo de tiempo de reacción, conforme a los estándares de evaluación de respuesta humana (ISO 23274), consiste en la activación secuencial y acumulativa de cinco pares de indicadores luminosos rojos, con un intervalo de 0,500 segundos por par, emulando el sistema de señalización de un semáforo de Fórmula 1. Cada par de indicadores permanece encendido tras su activación. Tras la activación del último par, se introduce un intervalo aleatorio entre 0,500 y 5,000 segundos antes de la desactivación simultánea de todos los indicadores. En este ensayo, el intervalo aleatorio fue de ${(randomDelay / 1000).toFixed(3)} segundos. El tiempo de reacción se mide desde la desactivación de los indicadores hasta la interacción del usuario con la pantalla táctil, con una precisión de ±1 milisegundo.<br><br>
                        <strong>Parámetros del ensayo:</strong><br>
                        - Número de diligencias: ${diligencias}<br>
                        - Matrícula: ${matricula}<br>
                        - Fecha y hora: ${new Date().toLocaleString('es-ES')}<br>
                        - Dispositivo: ${navigator.userAgent}<br>
                        - Tiempo de reacción registrado: ${tiempoReaccion.toFixed(3)} segundos<br>
                        - Hash SHA-256: <span id="hash-placeholder">Calculando...</span>
                    `;
                    startBtn.disabled = false;
                    captureBtn.disabled = false;
                    area.innerText = 'Prepárate para interactuar nuevamente';
                    const hash = await downloadReactionData(tiempoReaccion, randomDelay / 1000, diligencias, matricula);
                    document.getElementById('hash-placeholder').innerText = hash;
                    console.log('Tiempo de reacción capturado:', tiempoReaccion);
                    area.removeEventListener('click', captureReaction);
                    area.removeEventListener('touchstart', captureReaction);
                };

                area.addEventListener('click', captureReaction, { once: true });
                area.addEventListener('touchstart', captureReaction, { once: true });
            } catch (error) {
                console.error('Error en capturarTiempoReaccion:', error);
            }
        }

        async function downloadReactionData(tiempoReaccion, randomDelay, diligencias, matricula) {
            try {
                console.log('Exportando datos de reacción...');
                const now = new Date().toLocaleString('es-ES');
                let csv = `Número de diligencias,${diligencias}\nMatrícula,${matricula}\nFecha y hora,${now}\nDispositivo,${navigator.userAgent}\n`;
                csv += `Tiempo de reacción (s),${tiempoReaccion.toFixed(3)}\nIntervalo aleatorio (s),${randomDelay.toFixed(3)}\n`;
                const hash = await generateHash(csv);
                document.getElementById('reaction-hash').innerText = hash;
                csv += `Hash SHA-256,${hash}\n`;
                const blob = new Blob([csv], { type: 'text/csv' });
                saveAs(blob, `reaccion_${diligencias.replace(/[/\s]/g, '_')}.csv`);
                console.log('Datos de reacción exportados');
                return hash;
            } catch (error) {
                console.error('Error en downloadReactionData:', error);
                return 'N/A';
            }
        }

        // Captura de pantalla
        document.getElementById('capture-screenshot').addEventListener('click', () => {
            try {
                console.log('Capturando pantalla...');
                html2canvas(document.querySelector('#reaccion')).then(canvas => {
                    const diligencias = document.getElementById('reaccion-diligencias').value || 'N/A';
                    canvas.toBlob(blob => {
                        saveAs(blob, `resultado_reaccion_${diligencias.replace(/[/\s]/g, '_')}.png`);
                        console.log('Captura exportada');
                    });
                });
            } catch (error) {
                console.error('Error en capture-screenshot:', error);
            }
        });

        // Iniciar el test
        document.getElementById('iniciar-test').addEventListener('click', iniciarTestReaccion);

        // Inicializar nivel al cargar
        try {
            initBubbleLevel();
        } catch (error) {
            console.error('Error al inicializar nivel al cargar:', error);
        }

        // Registrar Service Worker (deshabilitado temporalmente para depuración)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(() => console.log('Service Worker registrado'))
                .catch(err => console.error('Error al registrar Service Worker:', err));
        }
        */
    </script>
</body>
</html>
